/*
题目描述：有一个二维矩阵 A 其中每个元素的值为 0 或 1 。移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。返回尽可能高的分数。示例：输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
输出：39
解释：
转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39

规则： 只能进行两种操作，将行的01翻转或者将列的01翻转

1、初始
[0,0,1,1]
[1,0,1,0]
[1,1,0,0]

2、首列均为1，翻转第一行
[1,1,0,0]
[1,0,1,0]
[1,1,0,0]

3、此时不应该改变行，而翻转列，每一列中，保证1的个数多余0的个数
[1,1,1,1]
[1,0,0,1]
[1,1,1,1]

* */

/**
 * @param {number[][]} A
 * @return {number}
 */
var matrixScore = function (A) {
  // 翻转列
  let flipCol = index => {
    // 遍历每一行，i为行号，index是第几列
    for (let i = 0; i < A.length; i++) {
      A[i][index] = A[i][index] ^ 1;
    }
  };
  
  // 翻转行， index 为第几行， i为第几列
  let flipRow = index => {
    // 遍历每一行的元素
    A[index] = A[index].map(row => row ^ 1);
  };
  
  // 遍历每一列
  for (let i = 0; i < A[0].length; i++) {
    // 每一列中 1 的个数
    let colVal = 0;
    
    // 遍历每一行
    for (let j = 0; j < A.length; j++) {
      // 如果第一列且值为0, 对该行翻转
      if (i === 0 && A[j][i] === 0) {
        flipRow(j);
        colVal = A.length;
      } else {
        // 如果非第一列且为1 则累加基数
        colVal += A[j][i];
      }
    }
    
    // 遍历玩一列之后，根据计算得到每一列中 1 的个数，小于列高度时，对列翻转
    if (colVal < (A.length / 2)) {
      flipCol(i);
    }
  }
  
  let sum = 0;
  for (let i = 0; i < A.length; i++) {
    // 字符串的 1001 二进制数,转成 10 进制int类型
    sum += parseInt(A[i].join(''), 2);
  }
  
  return sum;
};

const t = [[1, 1, 1, 1], [1, 0, 0, 1], [1, 1, 1, 1]];
const c = [[0, 0, 1, 1], [1, 0, 1, 0], [1, 1, 0, 0]];

console.log(matrixScore(t));
